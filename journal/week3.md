# Week 3 — Decentralized Authentication

## Business Scenario
The fractional CTO has suggested that authentication be solved before implementing any other business logic in the application and to ensure that we use a decentralized authentication service and specifically Amazon Cognito.

## Technical Tasks
Provision via ClickOps a Amazon Cognito User Pool
Install and configure Amplify client-side library for Amazon Congito
Implement API calls to Amazon Coginto for custom login, signup, recovery and forgot password page
Show conditional elements and data based on logged in or logged out
Verify JWT Token server side to serve authenticated API endpoints in Flask Application 

## Weekly Outcome
Practical knowledge of implementing a decentralized authentication service into a web-application with custom login and signup pages in a react application.

## Possible Spend Considerations
- Monthly active users (MAU), up to 50000 free MAU.
- Amazon simple email service (SES), up to 62000 free outbound email message.


## Alternatives and Considerations
We could have used Auth0 which is a popular decentralized authentication service which has a free-tier. Since we are building a social media website we have to consider the cost of Monthly Active Users (MAUs)
In practice a social media platform would likely roll its own decentralized authentication service
AuthN would have put on a good technical path to roll own decentralized authentication service however it requires Postgres and Redis so it would be too many extra moving parts and costs considerations for the scope of this bootcamp
Azure AD B2C is another possible solution. Its low cost has support for many Identity Providers (IpDs)

## Security Considerations
…

## Homework Challenges 
[Medium] Decouple the JWT verify from the application code by writing a  Flask Middleware
[Hard] Decouple the JWT verify by implementing a Container Sidecar pattern using AWS’s official Aws-jwt-verify.js library
[Hard] Decouple the JWT verify process by using Envoy as a sidecar https://www.envoyproxy.io/
[Hard]  Implement a IdP login eg. Login with Amazon or Facebook or Apple.
[Easy] Implement MFA that send an SMS (text message), warning this has spend, investigate spend before considering, text messages are not eligible for AWS Credits

## Required Homework 

### Setup Cognito User Pool

#### Selecting a Cognito Provider
With AWS Cognito you have two options. Cognito user pools or identity pools. *Cognito user pools* allow users to sign in or sign up using their email, phone or username. *Cognito identity pools*, on the other hand allow users to authenticate using a third party federation identity provider such as Facebook, Google, Amazon and exchange the authentication access token generated by this flow for temporary AWS credentials, that the application can use to access AWS resources. 

We opted for Cognito user pools as we only need basic authentication to integrate with our application. However, it's important to know that we're not restricted to either using user pools or identity pools, we can actually use both options at the same time if needed. In addition, we selected the email option for users to sign in.

![Cognito User Pool Setup](../_docs/assets/week3/signuppageerror2weshouldchooseonlyemailfixed.png)
At first we had an error, instead of choosing


We selected the cognito default password policy that requires users to create a password with a minimum of 8 characters and that includes at least 1 number, 1 special character, 1 uppercase letter and 1 lowercase letter.
![Cognito User Pool Setup](./assets/week-03/creatinguserpool2.png)

We selected *No MFA* as we don't need an extra layer of security for this application. 
![Cognito User Pool Setup](./assets/week-03/cognito-04.png)
To allow users to recover their account we select the *Email only* option. We could also have used the SMS only, but this is a paid feature.
![Cognito User Pool Setup](./assets/week-03/cognito-05.png)
We enabled users to sign up to the application by themselves (without the need for admin aproval).
![Cognito User Pool Setup](./assets/week-03/cognito-06.png)

In this step we allowed Cognito to automatically send an email to users so they can confirm they successfully sign up. 
![Cognito User Pool Setup](./assets/week-03/cognito-07.png)

Then we selected the required attributes user need to provide in other to sign up.
![Cognito User Pool Setup](./assets/week-03/cognito-08.png)

We didn't need to create any custom attributes (e.g. favorite color lol)
![Cognito User Pool Setup](./assets/week-03/cognito-09.png)

There's two ways we can send email messages in Cognito. Through SES or through Cognito. SES configuration is a little more involved, so we opted for the simpler authentication method and we went with the "Send email with Cognito" option.
![Cognito User Pool Setup](./assets/week-03/cognito-10.png)

After supplied the configuration for our user pool, we gave it a name. In this case we named it "cruddur-user-pool". `NOTE: I later changed it to just "cruddur"`.
![Cognito User Pool Setup](./assets/week-03/cognito-11.png)

We did not select the Hosted UI option as it does not provide a good developer experience.
![Cognito User Pool Setup](./assets/week-03/cognito-12.png)

Here's a snapshot of the created cognito user pool with the first 4 digits of my account for homework proof.
![Cognito User Pool Setup](./assets/week-03/cognito-00.png)



### Implement Custom Signin Page


Change into the `./frontend-react-js` directory 
```sh
cd ./frontend-react-js
```

Install the amplify library inside the `./frontend-react-js` project directory. 
```sh
npm i aws-amplify -S
```

Import amplify client into `./src/App.js`
```js
import { Amplify } from 'aws-amplify';

import {
  createBrowserRouter,
  RouterProvider
} from "react-router-dom";
...
```

[Configure amplify client](https://docs.amplify.aws/lib/client-configuration/configuring-amplify-categories/q/platform/js/#general-configuration)
```js
Amplify.configure({
  "AWS_PROJECT_REGION": process.env.REACT_AWS_PROJECT_REGION,
  "aws_cognito_region": process.env.REACT_APP_AWS_COGNITO_REGION,
  "aws_user_pools_id": process.env.REACT_APP_AWS_USER_POOLS_ID,
  "aws_user_pools_web_client_id": process.env.REACT_APP_CLIENT_ID,
  "oauth": {},
  Auth: {
    // We are not using an Identity Pool
    // identityPoolId: process.env.REACT_APP_IDENTITY_POOL_ID, 
    // REQUIRED - Amazon Cognito Identity Pool ID
    region: process.env.REACT_AWS_PROJECT_REGION,           
    // REQUIRED - Amazon Cognito Region
    userPoolId: process.env.REACT_APP_AWS_USER_POOLS_ID,         
    // OPTIONAL - Amazon Cognito User Pool ID
    userPoolWebClientId: process.env.REACT_APP_AWS_USER_POOLS_WEB_CLIENT_ID,   
    // OPTIONAL - Amazon Cognito Web Client ID (26-char alphanumeric string)
  }
});
```

Add the following environment variables to your **LOCAL** `frontend-react-js.env` file
```sh
AWS_DEFAULT_REGION="us-east-1"
REACT_APP_AWS_PROJECT_REGION="${AWS_DEFAULT_REGION}"
REACT_APP_AWS_COGNITO_REGION="${AWS_DEFAULT_REGION}"
REACT_APP_AWS_USER_POOLS_ID="us-east-1_ur@nd0mtext"
REACT_APP_CLIENT_ID="309uafosiefja38y2asdjf3"
```

Added sign in support 
```js
// SignIn.js
const onsubmit = async (event) => {
    event.preventDefault();
    setErrors('')

    Auth
    .signIn(email, password)
    .then(user => {
        const jwtAccessToken = user.signInUserSession.accessToken.jwtToken;
        localStorage.setItem("access_token", jwtAccessToken)
        window.location.href = "/"
    })
    .catch(error => { 
        if (error.code === 'UserNotConfirmedException') {
        window.location.href = "/confirm"
        }
        console.error(error.message);
        setErrors(error.message);
    });

    return false;
}
```

Added sign out support 
```js
// ProfileInfo.js
import { Auth } from "amplify"

...

const signOut = async () => {
  try {
      await Auth.signOut({ global: true });
      window.location.href = "/"
  } catch (error) {
      console.log('error signing out: ', error);
  }
}
```

Conditionally showed components based on whether the user is logged in or not 
```js
  // check if we are authenicated
  const checkAuth = async () => {
    Auth.currentAuthenticatedUser({
      // Optional, By default is false. 
      // If set to true, this call will send a 
      // request to Cognito to get the latest user data
      bypassCache: false 
    })
    .then((user) => {
      console.log('user',user);
      return Auth.currentAuthenticatedUser()
    }).then((cognito_user) => {
        setUser({
          display_name: cognito_user.attributes.name,
          handle: cognito_user.attributes.preferred_username
        })
    })
    .catch((err) => console.log(err));
  };

  React.useEffect(()=>{
    //prevents double call
    if (dataFetchedRef.current) return;
    dataFetchedRef.current = true;

    loadData();
    checkAuth();
  }, [])
```

#### User Creation and troubleshooting 
To test whether we could log users in, we created a new user using the Cognito console. Unfortunately, this put the user in a `FORCE_CHANGE_PASSWORD` state. This happens when a user does not have a password.
![Creating a new user for testing purposes](./assets/week-03/cognito-17.png)

To overcome this issue we set a password for the user manually using the AWS CLI. 
```sh
aws cognito-idp admin-set-user-password \
  --user-pool-id <your-user-pool-id> \
  --username <username> \
  --password <password> \
  --permanent
```

-   `aws cognito-idp admin-set-user-password`: This is the AWS CLI command to set a new password for a user in an Amazon Cognito user pool.
-   `--user-pool-id`: This is a required parameter that specifies the ID of the user pool where the user is located. Replace `<your-user-pool-id>` with the actual ID of your user pool.
-   `--username`: This is a required parameter that specifies the username of the user whose password you want to reset. Replace `<username>` with the actual username of the user.
-   `--password`: This is a required parameter that specifies the new password for the user. Replace `<password>` with the actual new password you want to set.
-   `--permanent`: This is an optional parameter that specifies whether the new password is permanent or temporary. If you include this parameter, the new password is permanent. If you omit this parameter, the new password is temporary and the user will be prompted to change it on their next login.

Note that in order to use this command, you must have the appropriate permissions to manage users in the specified user pool.

---

We used the frontend UI to test if we successfully integrated cognito with our react app. We were looking for the following message if cognito was well integrated:
![Cognito Sign in test](./assets/week-03/cognito-18.png)



### Implement Custom Signup Page
```js
// SignUp.js
  const onsubmit = async (event) => {
    event.preventDefault();
    setErrors('')
    try {
      const signUpProps = {
        username: email,
        password: password,
        attributes: {
          name: name,
          email: email,
          preferred_username: username,
        },
        autoSignIn: { // optional - enables auto sign in after user is confirmed
          enabled: true,
        }
      }

      const { user } = await Auth.signUp(signUpProps);
      window.location.href = `/confirm?email=${email}`

    } catch (error) {
        console.log(error);
        setErrors(error.message)
    }
    return false
  }
```

### Implement Custom Confirmation Page
```js
// ConfirmationPage.js
import { Auth } from "aws-amplify";

// Resend Code
const resend_code = async (event) => {
  setErrors('')
  try {
    await Auth.resendSignUp(email); 
    console.log('code resent successfully');
    setCodeSent(true)

  } catch (err) {
    console.error(err)
    if (err.message == 'Username cannot be empty'){
      setErrors("You need to provide an email in order to send Resend Activiation Code")   
    } else if (err.message == "Username/client id combination not found."){
      setErrors("Email is invalid or cannot be found.")   
    }
  }
}
```
```js
// Confirm Sign UP
  const onsubmit = async (event) => {
    event.preventDefault();
    setErrors('')
    try {
      await Auth.confirmSignUp(email, code);
      window.location.href = "/"
    } catch (error) {
      setErrors(error.message)
    }
    return false
  }
```

### Implement Custom Recovery Page
```js
// RecoverPage.js
import { Auth } from "aws-amplify";

  const onsubmit_send_code = async (event) => {
    event.preventDefault();
    setErrors('')
    Auth.forgotPassword(username)
    .then((data) => setFormState('confirm_code') )
    .catch((err) => setErrors(err.message) );
    return false
  }
  
  const onsubmit_confirm_code = async (event) => {
    event.preventDefault();
    setErrors('')
    if (password == passwordAgain){
      Auth.forgotPasswordSubmit(username, code, password)
      .then((data) => setFormState('success'))
      .catch((err) => setErrors(err.message) );
    } else {
      setErrors('Passwords do not match')
    }
    return false
  }
```

### Server-side token verification
Frontend setup 
```js
// HomeFeedPage.js
  const loadData = async () => {
    try {
      const backend_url = `${process.env.REACT_APP_BACKEND_URL}/api/activities/home`
      const res = await fetch(backend_url, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("access_token")}`
        },
        method: "GET"
      });
      let resJson = await res.json();
      if (res.status === 200) {
        setActivities(resJson)
      } else {
        console.log(res)
      }
    } catch (err) {
      console.log(err);
    }
  };
```

Backend setup in `app.js`
```python
cors = CORS(
  app, 
  resources={r"/api/*": {"origins": origins}},
  headers=['Content-Type', 'Authorization'], 
  expose_headers='Authorization',
  methods="OPTIONS,GET,HEAD,POST"
)
```

Created the following 
```python
import time
import requests
from jose import jwk, jwt
from jose.exceptions import JOSEError
from jose.utils import base64url_decode

class FlaskAWSCognitoError(Exception):
  pass

class TokenVerifyError(Exception):
  pass

def extract_access_token(request_headers):
    """
    Extracts the access token from the Authorization header of an HTTP request.
    """
    access_token = None
    auth_header = request_headers.get("Authorization")
    if auth_header and " " in auth_header:
        _, access_token = auth_header.split()
    return access_token

class CognitoJwtToken:
    def __init__(self, user_pool_id, user_pool_client_id, region, request_client=None):
        """
        Initializes a new instance of the CognitoJwtToken class.
        """
        self.region = region
        if not self.region:
            raise FlaskAWSCognitoError("No AWS region provided")
        self.user_pool_id = user_pool_id
        self.user_pool_client_id = user_pool_client_id
        self.claims = None
        if not request_client:
            self.request_client = requests.get
        else:
            self.request_client = request_client
        self._load_jwk_keys()


    def _load_jwk_keys(self):
        """
        Downloads the JSON Web Key (JWK) keys for the specified user pool
        and loads them into memory.
        """
        keys_url = f"https://cognito-idp.{self.region}.amazonaws.com/{self.user_pool_id}/.well-known/jwks.json"
        try:
            response = self.request_client(keys_url)
            self.jwk_keys = response.json()["keys"]
        except requests.exceptions.RequestException as e:
            raise FlaskAWSCognitoError(str(e)) from e

    def _extract_headers(token):
        """
        Extracts the headers from a JWT token without verifying its signature.
        """
        try:
            headers = jwt.get_unverified_headers(token)
            return headers
        except JOSEError as e:
            raise TokenVerifyError(str(e)) from e

    def _find_pkey(self, headers):
        """
        Searches for the public key associated with the specified JWT token header
        within the downloaded JWK keys.
        """
        kid = headers["kid"]
        # search for the kid in the downloaded public keys
        key_index = -1
        for i in range(len(self.jwk_keys)):
            if kid == self.jwk_keys[i]["kid"]:
                key_index = i
                break
        if key_index == -1:
            raise TokenVerifyError("Public key not found in jwks.json")
        return self.jwk_keys[key_index]

    def _verify_signature(token, pkey_data):
        """
        Verifies the signature of a JWT token using the public key obtained from the token's header.
        """
        try:
            # construct the public key
            public_key = jwk.construct(pkey_data)
        except JOSEError as e:
            raise TokenVerifyError(str(e)) from e
        # get the last two sections of the token,
        # message and signature (encoded in base64)
        message, encoded_signature = str(token).rsplit(".", 1)
        # decode the signature
        decoded_signature = base64url_decode(encoded_signature.encode("utf-8"))
        # verify the signature
        if not public_key.verify(message.encode("utf8"), decoded_signature):
            raise TokenVerifyError("Signature verification failed")

    def _extract_claims(token):
        """
        Extracts the claims (payload) of a JWT token without verifying its signature.
        """
        try:
            claims = jwt.get_unverified_claims(token)
            return claims
        except JOSEError as e:
            raise TokenVerifyError(str(e)) from e

    def _check_expiration(claims, current_time):
        """
        Checks whether the specified JWT token has expired.
        """
        if not current_time:
            current_time = time.time()
        if current_time > claims["exp"]:
            raise TokenVerifyError("Token is expired")  # probably another exception

    def _check_audience(self, claims):
        """
        Checks whether the audience (client ID) of the specified JWT token matches
        the client ID specified during initialization.
        """
        audience = claims["aud"] if "aud" in claims else claims["client_id"]
        if audience != self.user_pool_client_id:
            raise TokenVerifyError("Token was not issued for this audience")

    def verify(self, token, current_time=None):
        """ https://github.com/awslabs/aws-support-tools/blob/master/Cognito/decode-verify-jwt/decode-verify-jwt.py """

        """
        Validates the specified JWT token by performing the following checks:
        - extracting its headers and finding the corresponding JWK public key;
        - verifying its signature using 
        """
		if not token:
			raise TokenVerifyError("No token provided")
			
        headers = self._extract_headers(token)
        pkey_data = self._find_pkey(headers)
        self._verify_signature(token, pkey_data)

        claims = self._extract_claims(token)
        self._check_expiration(claims, current_time)
        self._check_audience(claims)

        self.claims = claims 
        return claims
```

### Watch about different approaches to verifying JWTs
![Side Car container pattern](./assets/week-03/cognito-19.png)

![Lambda Authorizers](./assets/week-03/cognito-20.png)


---

<!-- 
## Homework Challenges
- [ ] [Medium] Decouple the JWT verify from the application code by writing a  Flask Middleware
- [ ] [Hard] Decouple the JWT verify by implementing a Container Sidecar pattern using AWS’s official Aws-jwt-verify.js library
- [ ] [Hard] Decouple the JWT verify process by using Envoy as a sidecar https://www.envoyproxy.io/
- [ ] [Hard]  Implement a IdP login eg. Login with Amazon or Facebook or Apple.
- [ ] [Easy] Implement MFA that send an SMS (text message), warning this has spend, investigate spend before considering, text messages are not eligible for AWS Credits

### [Medium] Decouple the JWT verify from the application code by writing a  Flask Middleware



### [Hard] Decouple the JWT verify by implementing a Container Sidecar pattern using AWS’s official Aws-jwt-verify.js library



### [Hard] Decouple the JWT verify process by using [Envoy](https://www.envoyproxy.io/) as a sidecar 



### [Hard]  Implement a IdP login eg. Login with Amazon or Facebook or Apple.



### [Easy] Implement MFA that send an SMS (text message), warning this has spend, investigate spend before considering, text messages are not eligible for AWS Credits
